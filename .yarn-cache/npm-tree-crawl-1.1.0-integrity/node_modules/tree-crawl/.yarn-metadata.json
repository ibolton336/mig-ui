{
  "manifest": {
    "name": "tree-crawl",
    "version": "1.1.0",
    "description": "Agnostic tree traversal library.",
    "author": {
      "name": "Nicolas Gryman",
      "email": "ngryman@gmail.com",
      "url": "http://ngryman.sh/"
    },
    "license": "MIT",
    "repository": {
      "type": "git",
      "url": "https://github.com/ngryman/tree-crawl.git"
    },
    "main": "dist/tree-crawl.js",
    "browser": "dist/tree-crawl.js",
    "module": "dist/tree-crawl.ems.js",
    "jsnext:main": "index.js",
    "types": "index.d.ts",
    "engines": {
      "node": ">=5"
    },
    "files": [
      "index.js",
      "index.d.ts",
      "lib/",
      "dist/"
    ],
    "scripts": {
      "lint": "eslint *.js {lib,test}/**/*.js",
      "pretest": "npm run lint",
      "test": "cross-env NODE_ENV=test nyc ava",
      "debug": "cross-env NODE_ENV=debug inspect -r babel-register -r ./test/helpers/fixtures.js --debug-exception node_modules/ava/profile.js",
      "docs": "documentation readme index.js lib/internal/context.js -c documentation.yml -s API",
      "start": "meta dev",
      "coverage": "nyc report --reporter=text-lcov | codecov",
      "see-coverage": "nyc report --reporter=html && open coverage/index.html",
      "check-coverage": "nyc check-coverage --lines 100 --functions 100 --branches 100",
      "bundle": "cross-env NODE_ENV=build rollup -c",
      "minify": "uglifyjs dist/tree-crawl.js -c -m --reserved-file .reserved --mangle-props -o dist/tree-crawl.min.js",
      "build": "npm run bundle && npm run minify",
      "prepublish": "npm run build",
      "bench": "npm run bundle && node ./perf/bench.js",
      "profile": "npm run bundle && devtool ./perf/profile.js",
      "trace": "npm run bundle && node-irhydra ./perf/trace.js"
    },
    "keywords": [
      "tree",
      "n-ary tree",
      "k-ary tree",
      "n-way tree",
      "multiway tree",
      "rose tree",
      "generic",
      "agnostic",
      "traverse",
      "traversal",
      "walk",
      "visit",
      "visitor",
      "recursive",
      "breadth first",
      "preorder",
      "postorder"
    ],
    "ava": {
      "require": [
        "babel-register",
        "./test/helpers/fixtures.js"
      ]
    },
    "devDependencies": {
      "ava": "^0.22.0",
      "babel-plugin-external-helpers": "^6.22.0",
      "babel-plugin-istanbul": "^4.1.1",
      "babel-preset-env": "^1.3.1",
      "benchmark": "^2.1.3",
      "clone": "^2.0.0",
      "codecov": "^3.7.1",
      "cross-env": "^5.0.0",
      "documentation": "^5.3.3",
      "eslint": "^4.9.0",
      "eslint-config-ngryman": "^1.7.1",
      "nyc": "^11.2.1",
      "rollup": "^0.54.1",
      "rollup-plugin-babel": "^3.0.2",
      "rollup-plugin-cleanup": "^1.0.0",
      "rollup-plugin-commonjs": "^8.0.2",
      "rollup-plugin-node-resolve": "^3.0.0",
      "uglify-js": "^3.0.0"
    },
    "_registry": "npm",
    "_loc": "/Users/ibolton/Library/Caches/Yarn/v6/npm-tree-crawl-1.1.0-integrity/node_modules/tree-crawl/package.json",
    "readmeFilename": "readme.md",
    "readme": "# tree-crawl [![travis][travis-image]][travis-url] [![codecov][codecov-image]][codecov-url] [![greenkeeper][greenkeeper-image]][greenkeeper-url] [![size][size-image]][size-url]\n\n> Agnostic tree traversal library.\n\n[travis-image]: https://img.shields.io/travis/ngryman/tree-crawl.svg?style=flat\n[travis-url]: https://travis-ci.org/ngryman/tree-crawl\n[codecov-image]: https://img.shields.io/codecov/c/github/ngryman/tree-crawl.svg\n[codecov-url]: https://codecov.io/github/ngryman/tree-crawl\n[greenkeeper-image]: https://badges.greenkeeper.io/ngryman/tree-crawl.svg\n[greenkeeper-url]: https://greenkeeper.io/\n[size-image]: http://img.badgesize.io/https://unpkg.com/tree-crawl@1.0.0/dist/tree-crawl.min.js?compression=gzip\n[size-url]: https://unpkg.com/tree-crawl@1.0.0/dist/tree-crawl.min.js\n\n-   **Agnostic**: Supports any kind of tree. You provide a way to access a node's children, that's it.\n-   **Fast**: Crafted to be optimizer-friendly. See [performance](#performance) for more details.\n-   **Mutation friendly**: Does not ðŸ’¥ when you mutate the tree.\n-   **Multiple orders**: Supports DFS pre and post order and BFS traversals.\n\n## Quickstart\n\n### Installation\n\nYou can install `tree-crawl` with `yarn`:\n\n```sh\n$ yarn add tree-crawl\n```\n\nAlternatively using `npm`:\n\n```sh\n$ npm install --save tree-crawl\n```\n\n### Usage\n\n```js\nimport crawl from 'tree-crawl'\n\n// traverse the tree in pre-order\ncrawl(tree, console.log)\ncrawl(tree, console.log, { order: 'pre' })\n\n// traverse the tree in post-order\ncrawl(tree, console.log, { order: 'post' })\n\n// traverse the tree using `childNodes` as the children key\ncrawl(tree, console.log, { getChildren: node => node.childNodes })\n\n// skip a node and its children\ncrawl(tree, (node, context) => {\n  if ('foo' === node.type) {\n    context.skip()\n  }\n})\n\n// stop the walk\ncrawl(tree, (node, context) => {\n  if ('foo' === node.type) {\n    context.break()\n  }\n})\n\n// remove a node\ncrawl(tree, (node, context) => {\n  if ('foo' === node.type) {\n    context.parent.children.splice(context.index, 1)\n    context.remove()\n  }\n})\n\n// replace a node\ncrawl(tree, (node, context) => {\n  if ('foo' === node.type) {\n    const node = {\n      type: 'new node',\n      children: [\n        { type: 'new leaf' }\n      ]\n    }\n    context.parent.children[context.index] = node\n    context.replace(node)\n  }\n})\n```\n\n## FAQ\n\n### How can I get the path of the current node ([#37](https://github.com/ngryman/tree-crawl/issues/37))?\n\n**tl;dr It's easy for DFS, less easy for BFS**\n\nIf you are using DFS you can use the following utility function:\n```javascript\nconst getPath = context =>\n  context.cursor.stack.xs.reduce((path, item) => {\n    if (item.node) {\n      path.push(item.node)\n    }\n    return path\n  }, [])\n```\nIf you are really concerned about performance, you could read items from the stack directly. Each item has a `node` and `index` property that you can use. The first item in the stack can be discarded and will have a `node` set to `null`. Be aware that you should not mutate the stack, or it will break the traversal.\n\nIf you are using BFS, things gets more complex. A *simple hacky* way to do so is to traverse the tree using DFS first. You can ad a `path` property to your nodes using the method above. And then do your regular BFS traversal using that `path` property.\n\n## API\n\n<!-- Generated by documentation.js. Update this documentation by updating the source code. -->\n\n### Iteratee\n\n-   **See: [Traversal context](#traversal-context).**\n\nCalled on each node of the tree.\n\nType: [Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)\n\n**Parameters**\n\n-   `node` **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Node being visited.\n-   `context` **[Context](#context)** Traversal context\n\n### Options\n\nWalk options.\n\nType: [Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)\n\n**Parameters**\n\n-   `node`  \n\n**Properties**\n\n-   `getChildren` **[Function](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/function)?** Return a node's children.\n-   `order` **(`\"pre\"` \\| `\"post\"` \\| `\"bfs\"`)?** Order of the walk either in DFS pre or post order, or\n    BFS.\n\n**Examples**\n\n_Traverse a DOM tree._\n\n```javascript\ncrawl(document.body, doSomeStuff, { getChildren: node => node.childNodes })\n```\n\n_BFS traversal_\n\n```javascript\ncrawl(root, doSomeStuff, { order: 'bfs' })\n```\n\n### crawl\n\nWalk a tree recursively.\n\nBy default `getChildren` will return the `children` property of a node.\n\n**Parameters**\n\n-   `root` **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Root node of the tree to be walked.\n-   `iteratee` **[Iteratee](#iteratee)** Function invoked on each node.\n-   `options` **[Options](#options)?** Options customizing the walk.\n\n### Context\n\nA traversal context.\n\nFour operations are available. Note that depending on the traversal order, some operations have\nno effects.\n\n**Parameters**\n\n-   `flags` **Flags** \n-   `cursor` **Cursor** \n\n#### skip\n\nSkip current node, children won't be visited.\n\n**Examples**\n\n```javascript\ncrawl(root, (node, context) => {\n  if ('foo' === node.type) {\n    context.skip()\n  }\n})\n```\n\n#### break\n\nStop traversal now.\n\n**Examples**\n\n```javascript\ncrawl(root, (node, context) => {\n  if ('foo' === node.type) {\n    context.break()\n  }\n})\n```\n\n#### remove\n\nNotifies that the current node has been removed, children won't be visited.\n\nBecause `tree-crawl` has no idea about the intrinsic structure of your tree, you have to\nremove the node yourself. `Context#remove` only notifies the traversal code that the structure\nof the tree has changed.\n\n**Examples**\n\n```javascript\ncrawl(root, (node, context) => {\n  if ('foo' === node.type) {\n    context.parent.children.splice(context.index, 1)\n    context.remove()\n  }\n})\n```\n\n#### replace\n\nNotifies that the current node has been replaced, the new node's children will be visited\ninstead.\n\nBecause `tree-crawl` has no idea about the intrinsic structure of your tree, you have to\nreplace the node yourself. `Context#replace` notifies the traversal code that the structure of\nthe tree has changed.\n\n**Parameters**\n\n-   `node` **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Replacement node.\n\n**Examples**\n\n```javascript\ncrawl(root, (node, context) => {\n  if ('foo' === node.type) {\n    const node = {\n      type: 'new node',\n      children: [\n        { type: 'new leaf' }\n      ]\n    }\n    context.parent.children[context.index] = node\n    context.replace(node)\n  }\n})\n```\n\n#### parent\n\nGet the parent of the current node.\n\nReturns **[Object](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object)** Parent node.\n\n#### depth\n\nGet the **depth** of the current node. The depth is the number of ancestors the current node\nhas.\n\nReturns **[Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** Depth.\n\n#### level\n\nGet the **level** of current node. The level is the number of ancestors+1 the current node has.\n\nReturns **[Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** Level.\n\n#### index\n\nGet the index of the current node.\n\nReturns **[Number](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number)** Node's index.\n\n## Performance\n\n`tree-crawl` is built to be super fast and traverse potentially huge trees. It's possible because it implements its own stack and queue for traversal algorithms and makes sure the code is optimizable by the VM.\n\nIf you do need real good performance please consider reading this [checklist] first.\n\nYour main objective is to keep the traversal code optimized and avoid de-optimizations and bailouts. To do so, your nodes should have the same [hidden class] and your code stay [monomorphic].\n\n[checklist]: http://mrale.ph/blog/2011/12/18/v8-optimization-checklist.html\n\n[hidden class]: http://mrale.ph/blog/2012/06/03/explaining-js-vms-in-js-inline-caches.html\n\n[monomorphic]: http://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html\n\n## Related\n\n-   [arbre](https://github.com/arbrejs/arbre) Agnostic tree library.\n-   [tree-mutate](https://github.com/ngryman/tree-mutate) Agnostic tree mutation library.\n-   [tree-morph](https://github.com/ngryman/tree-morph) Agnostic tree morphing library.\n\n## License\n\nMIT Â© [Nicolas Gryman](http://ngryman.sh)\n",
    "licenseText": "The MIT License (MIT)\n\nCopyright (c) Nicolas Gryman <ngryman@gmail.com> (ngryman.sh)\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the Software), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED AS IS, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.npmjs.org/tree-crawl/-/tree-crawl-1.1.0.tgz",
    "type": "tarball",
    "reference": "https://registry.npmjs.org/tree-crawl/-/tree-crawl-1.1.0.tgz",
    "hash": "",
    "integrity": "sha512-pQfQTKBYEJhA3kIV8fL1rJJR8hgVzgX4u4IJi1EjnEch8BOUC+KQsuPMD6Pf017Sc8XD64WaA4q8840XhsIrIA==",
    "registry": "npm",
    "packageName": "tree-crawl",
    "cacheIntegrity": "sha512-pQfQTKBYEJhA3kIV8fL1rJJR8hgVzgX4u4IJi1EjnEch8BOUC+KQsuPMD6Pf017Sc8XD64WaA4q8840XhsIrIA== sha1-PF5wS1nuxF64Im3dMCpAnXbNKLs="
  },
  "registry": "npm",
  "hash": "a507d04ca058109840de4215f1f2f5ac9251f21815ce05f8bb82098b51239c4721f013940be290b2e3cc0fa3dfd35ed273c5c3eb859a038abcf38d1786c22b20"
}